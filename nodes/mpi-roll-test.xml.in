<?xml version="1.0" standalone="no"?>

<kickstart>

<description>
MPI roll installation test.
http://www.mcs.anl.gov/research/projects/mpich2
http://www.open-mpi.org
http://mvapich.cse.ohio-state.edu
</description>

<copyright>
Copyright (c) 2000 - 2011 The Regents of the University of California.
All rights reserved. Rocks(r) v5.1 www.rocksclusters.org
</copyright>

<changelog>
</changelog>

<post>

/bin/mkdir -m 0755 /root/rolltests

<file name="/root/rolltests/mpi.t" perms="0755">
<![CDATA[#!/usr/bin/perl -w

use Test::More qw(no_plan);

my $appliance = $#ARGV >= 0 ? $ARGV[0] :
                -d '/export/rocks/install' ? 'Frontend' : 'Compute';
my $isCompute = $appliance eq 'Compute';
my $isFe = $appliance eq 'Frontend';
my $isLogin = $appliance eq 'Login';
my $output;

my $NODECOUNT = 4;
my $LASTNODE = $NODECOUNT - 1;
my $TESTFILE = 'rollmpi';
my $SUBMITUSER = 'diag';
my $SUBMITDIR = "/home/$SUBMITUSER/mpiroll";
`sudo -u $SUBMITUSER mkdir $SUBMITDIR`;

open(OUT, ">$TESTFILE.c");
print OUT <<END;
#include <stdio.h>
#include <mpi.h>

int main (int argc, char **argv) {
  int rank, size;
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);
  printf("Hello from process %d of %d\\n", rank, size);
  MPI_Finalize();
  return 0;
}
END
close(OUT);

my $modulecmd = "$ENV{MODULESHOME}/bin/modulecmd";

my @COMPILERS = (
  'ROLLCOMPILER',
);
my @NETWORKS = (
  'ROLLNETWORK',
);
my @MPIS = (
  'mpich2',
  'mvapich2',
  'openmpi',
);
foreach my $MPI (@MPIS) {
  foreach my $COMPILER (@COMPILERS) {
    foreach my $NETWORK (@NETWORKS) {

      my $SUBMITERR = "$SUBMITDIR/$TESTFILE.$MPI.$COMPILER.$NETWORK.err";
      my $SUBMITEXE = "$SUBMITDIR/$TESTFILE.$MPI.$COMPILER.$NETWORK.exe";
      my $SUBMITOUT = "$SUBMITDIR/$TESTFILE.$MPI.$COMPILER.$NETWORK.out";

      my $command = "$modulecmd bash clear yes; " .
                    "$modulecmd bash load $COMPILER ${MPI}_$NETWORK";
      $output = `$command`;
      $output =~ s/;\s*$//;
      $command = "eval '$output'; which mpicc; mpicc -o $TESTFILE $TESTFILE.c";
      $output = `$command`;
      $output =~ /(\S*mpicc)/;
      my $mpicc = $1 || 'mpicc';
      ok(-x $TESTFILE, "Compile with $mpicc");

      SKIP: {

        skip 'No exe', 1 if ! -x $TESTFILE;
        `sudo -u $SUBMITUSER cp $TESTFILE $SUBMITEXE`;

        my $fileopt = $MPI eq "mpich2" ? "" : "-machinefile \$PBS_NODEFILE";
        open(OUT, ">$TESTFILE.qsub");
        print OUT <<END;
#!/bin/csh
#PBS -l nodes=$NODECOUNT
#PBS -l walltime=5:00
#PBS -e $SUBMITERR
#PBS -o $SUBMITOUT
#PBS -V
#PBS -m n
module clear yes
module load $COMPILER ${MPI}_$NETWORK
if ("$MPI" == "mpich2") then
  echo 'secretword=whatever' > ~/.mpd.conf
  chmod 600 ~/.mpd.conf
  mpdboot -n $NODECOUNT -f \$PBS_NODEFILE
endif
cd $SUBMITDIR
which mpirun
mpirun $fileopt -np $NODECOUNT $SUBMITEXE
if ("$MPI" = "mpich2") then
  mpdallexit
  rm -f ~/.mpd.conf
endif
END
        close(OUT);
        $output = `sudo -u $SUBMITUSER qsub $TESTFILE.qsub`;
        $output =~ /(\d+)/;
        my $jobId = $1;
        while(`qstat $jobId` =~ / (Q|R) /) {
          sleep(1);
        }
        for(my $sec = 0; $sec < 60; $sec++) {
          last if -f $SUBMITOUT;
          sleep(1);
        }
        $output = `sudo -u $SUBMITUSER cat $SUBMITOUT`;
        $output =~ /(\S*mpirun)/;
        my $mpirun = $1 || 'mpirun';
        like($output, qr/process $LASTNODE of $NODECOUNT/, "Run with $mpirun");

      }

      `rm -f $TESTFILE`;

    }
  }
}
`rm -f $TESTFILE*`;
`sudo -u $SUBMITUSER rm -fr $SUBMITDIR`;
]]>
</file>

</post>

</kickstart> 
